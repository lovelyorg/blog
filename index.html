<!DOCTYPE html>
<html>
  <link rel="stylesheet" href="/index.css" />
  <link rel="stylesheet" href="/marked.ex.css" />

  <div id="app"></div>

  <script>
    // 无网络时使用本地资源
    const netCss = ['//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.3.1/build/styles/tomorrow.min.css']
    const localCss = ['/lib/styles/tomorrow.css']
    const netJs = [
      'https://unpkg.com/react@16/umd/react.production.min.js',
      'https://unpkg.com/react-dom@16/umd/react-dom.production.min.js',
      'https://unpkg.com/babel-standalone@6/babel.min.js',
      'https://cdn.jsdelivr.net/npm/marked/marked.min.js',
      '//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.3.1/build/highlight.min.js',
    ]
    const localJs = [
      '/lib/react.production.min.js',
      '/lib/react-dom.production.min.js',
      '/lib/babel.min.js',
      '/lib/marked.min.js',
      '/lib/highlight.min.js',
    ]
    const isLocal = window.location.protocol === 'http:'
    const staticResource = isLocal
      ? {
          css: localCss,
          js: localJs,
        }
      : {
          css: netCss,
          js: netJs,
        }
    staticResource.css.forEach((m) => {
      document.write(`<link rel="stylesheet" href="${m}">`)
    })
    staticResource.js.forEach((m) => {
      document.write(`<script src="${m}" ><\/script>`)
    })
  </script>

  <script>
    // 不能写到上个 script 标签里, 猜测原理为:一个标签里的代码会先执行完, 然后下载js资源, 完了结束script标签继续往后走
    marked.setOptions({
      highlight: function (code, language) {
        const validLanguage = hljs.getLanguage(language) ? language : 'plaintext'
        return hljs.highlight(validLanguage, code).value
      },
    })
  </script>

  <script type="text/babel">
    const domContainer = document.querySelector('#app')
    const useState = React.useState
    const useEffect = React.useEffect

    const Cate = (props) => {
      return (
        <ul className="cate">
          {props.cate.map((m) => (
            <li className="item">{m}</li>
          ))}
        </ul>
      )
    }

    const List = (props) => {
      const { list } = props
      return (
        <ul className="list">
          {list.map((m) => (
            <li className="item" title={m.name} key={m.path} onClick={() => props.srcChange(m.path)}>
              {m.name}
            </li>
          ))}
        </ul>
      )
    }

    const ViewMD = (props) => {
      const [md, setMd] = React.useState(null)

      useEffect(() => {
        if (props.src)
          fetch(props.src)
            .then((res) => res.text())
            .then((m) => setMd(marked(m)))
      }, [props.src])

      return (
        <div
          className="view"
          dangerouslySetInnerHTML={{
            __html: md,
          }}
        ></div>
      )
    }

    const View = (props) => {
      return <iframe className="view" allowfullscreen allowvr onmousewheel="" src={props.src}></iframe>
    }

    const App = (props) => {
      const [src, setSrc] = useState(null)
      const [cate, setCate] = useState({})
      useEffect(() => {
        fetch('cate.json')
          .then((res) => res.json())
          .then(setCate)
      }, [])

      return (
        <React.Fragment>
          <Cate cate={cate.cate || []} />
          <List list={cate.list || []} srcChange={setSrc} />
          <ViewMD src={src} />
        </React.Fragment>
      )
    }
    //<View src={src} />

    ReactDOM.render(<App />, document.querySelector('#app'))
  </script>
</html>
